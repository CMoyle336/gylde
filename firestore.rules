rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {



    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if the authenticated user is the owner
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Check if user is a participant in a list
    function isParticipant(participants) {
      return isAuthenticated() && request.auth.uid in participants;
    }

    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Anyone authenticated can read user profiles
      // (visibility filtering is done at query level)
      allow read: if isAuthenticated();
      
      // Only the owner can write to their own profile
      // Protected fields can only be set by Cloud Functions (admin SDK bypasses rules)
      allow create: if isOwner(userId)
        && !request.resource.data.keys().hasAny([
          'trustScore', 'subscription', 'isElite',
          'identityVerified', 'identityVerificationStatus', 'identityVerificationCompletedAt'
        ]);
      allow update: if isOwner(userId)
        && !request.resource.data.diff(resource.data).affectedKeys().hasAny([
          'trustScore', 'subscription', 'isElite',
          'identityVerified', 'identityVerificationStatus', 'identityVerificationCompletedAt'
        ]);
      allow delete: if false; // Deletion handled via Cloud Functions
      
      // ------------------------------------------
      // FAVORITES SUBCOLLECTION
      // User's favorited profiles
      // ------------------------------------------
      match /favorites/{targetUserId} {
        // Owner can read their own favorites
        // Target user can read favorites where they are the target
        // (needed for collectionGroup queries to count "favorited me")
        // Note: Private favorites are filtered client-side
        allow read: if isOwner(userId) 
          || (isAuthenticated() && request.auth.uid == resource.data.toUserId);
        
        // Only owner can create/update/delete their favorites
        allow create: if isOwner(userId) 
          && request.resource.data.fromUserId == userId
          && request.resource.data.toUserId == targetUserId;
        allow update: if isOwner(userId);
        allow delete: if isOwner(userId);
      }
      
      // ------------------------------------------
      // BLOCKS SUBCOLLECTION
      // Users blocked by this user
      // Managed exclusively by Cloud Functions
      // ------------------------------------------
      match /blocks/{blockedUserId} {
        // Owner can read their own blocks list
        allow read: if isOwner(userId);
        // All writes handled by Cloud Functions (admin SDK bypasses rules)
        allow write: if false;
      }
      
      // ------------------------------------------
      // BLOCKED BY SUBCOLLECTION
      // Users who have blocked this user
      // Managed exclusively by Cloud Functions
      // ------------------------------------------
      match /blockedBy/{blockerUserId} {
        // Owner can read their own blockedBy to enable real-time UI updates
        // (they know they're blocked when messaging/viewing is disabled, but 
        // this allows the UI to update immediately without refreshing)
        allow read: if isOwner(userId);
        // All writes handled by Cloud Functions
        allow write: if false;
      }
      
      // ------------------------------------------
      // ACTIVITIES SUBCOLLECTION
      // User's activity feed (notifications)
      // ------------------------------------------
      match /activities/{activityId} {
        // Owner can read their own activities
        // Users can also read activities where they are the fromUserId (to update their own view activity)
        allow read: if isOwner(userId) 
          || (isAuthenticated() && resource.data.fromUserId == request.auth.uid);
        
        // Activities are created by Cloud Functions
        // Users can only update (mark as read) their own activities
        // OR update activities they created (as fromUserId) - for view activity updates
        allow create: if false; // Cloud Functions only
        allow update: if isOwner(userId) 
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read'])
          || (isAuthenticated() && resource.data.fromUserId == request.auth.uid);
        allow delete: if isOwner(userId);
      }
      
      // ------------------------------------------
      // SAVED VIEWS SUBCOLLECTION
      // User's saved discovery filter views
      // ------------------------------------------
      match /savedViews/{viewId} {
        // Only owner can access their saved views
        allow read: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isOwner(userId);
        allow delete: if isOwner(userId);
      }
      
      // ------------------------------------------
      // PHOTO ACCESS REQUESTS SUBCOLLECTION
      // Requests this user has made to view others' private photos
      // ------------------------------------------
      match /photoAccessRequests/{requesterId} {
        // Owner can read all their outgoing requests
        // Requester can read their own request status
        allow read: if isOwner(userId) || isOwner(requesterId);
        // Writes handled by Cloud Functions
        allow write: if false;
      }
      
      // ------------------------------------------
      // PHOTO ACCESS RECEIVED SUBCOLLECTION
      // Requests this user has received from others
      // ------------------------------------------
      match /photoAccessReceived/{requesterId} {
        // Owner can read requests they've received
        // Requester can also read their own request status
        allow read: if isOwner(userId) || isOwner(requesterId);
        // Writes handled by Cloud Functions
        allow write: if false;
      }
      
      // ------------------------------------------
      // PHOTO ACCESS GRANTS SUBCOLLECTION
      // Users this user has granted access to
      // ------------------------------------------
      match /photoAccessGrants/{grantedUserId} {
        // Owner can read their grants
        // Granted user can also read to verify their access
        allow read: if isOwner(userId) || isOwner(grantedUserId);
        // Writes handled by Cloud Functions
        allow write: if false;
      }
      
      // ------------------------------------------
      // PRIVATE SUBCOLLECTION
      // Contains sensitive data: trustScore, subscription
      // Only the owner can read; only Cloud Functions can write
      // ------------------------------------------
      match /private/{docId} {
        // Only the owner can read their own private data
        allow read: if isOwner(userId);
        // All writes handled by Cloud Functions (admin SDK bypasses rules)
        allow write: if false;
      }
    }

    // ============================================
    // MATCHES COLLECTION
    // Mutual favorites between two users
    // ============================================
    match /matches/{matchId} {
      // Only participants can read matches
      allow read: if isAuthenticated() 
        && request.auth.uid in resource.data.users;
      
      // Matches are created/deleted by Cloud Functions when favorites are mutual
      allow write: if false;
    }

    // ============================================
    // PROFILE VIEWS COLLECTION
    // Records of who viewed whose profile
    // ============================================
    match /profileViews/{viewId} {
      // Users can read views where they are viewer or viewed
      allow read: if isAuthenticated() 
        && (request.auth.uid == resource.data.viewerId 
            || request.auth.uid == resource.data.viewedUserId);
      
      // Users can create views where they are the viewer
      allow create: if isAuthenticated() 
        && request.auth.uid == request.resource.data.viewerId
        && request.resource.data.viewedUserId != request.auth.uid; // Can't view yourself
      
      // Users can update their own views (to update timestamp)
      allow update: if isAuthenticated()
        && resource.data != null
        && request.auth.uid == resource.data.viewerId
        && request.resource.data.viewerId == resource.data.viewerId // Can't change viewer
        && request.resource.data.viewedUserId == resource.data.viewedUserId; // Can't change viewed
      
      // Users can delete their own views
      allow delete: if isAuthenticated() 
        && request.auth.uid == resource.data.viewerId;
    }

    // ============================================
    // CONVERSATIONS COLLECTION
    // Direct messages between users
    // ============================================
    match /conversations/{conversationId} {
      // Only participants can read conversations
      allow read: if isParticipant(resource.data.participants);
      
      // Participants can create conversations
      allow create: if isAuthenticated() 
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.participants.size() == 2; // Only 1-on-1 chats
      
      // Participants can update (for read status, last message, etc.)
      allow update: if isParticipant(resource.data.participants)
        && request.resource.data.participants == resource.data.participants; // Can't change participants
      
      // Conversations shouldn't be deleted, messages can be
      allow delete: if false;
      
      // ------------------------------------------
      // MESSAGES SUBCOLLECTION
      // ------------------------------------------
      match /messages/{messageId} {
        // Helper to get parent conversation
        function getConversation() {
          return get(/databases/$(database)/documents/conversations/$(conversationId)).data;
        }
        
        // Only conversation participants can read messages
        allow read: if isAuthenticated() 
          && request.auth.uid in getConversation().participants;
        
        // Only participants can create messages, and must be the sender
        allow create: if isAuthenticated() 
          && request.auth.uid in getConversation().participants
          && request.resource.data.senderId == request.auth.uid;
        
        // Participants can update messages (for read status, deletion flags)
        allow update: if isAuthenticated() 
          && request.auth.uid in getConversation().participants
          // Can't change sender or content of message
          && request.resource.data.senderId == resource.data.senderId;
        
        // Soft delete only - actual deletion not allowed from client
        allow delete: if false;
      }
    }

    // ============================================
    // DELETED MESSAGES ARCHIVE
    // For compliance/admin review
    // ============================================
    match /deletedMessages/{archiveId} {
      // Only admins can read archived messages
      allow read: if isAuthenticated() 
        && request.auth.token.admin == true;
      
      // Users can archive their own deleted messages
      allow create: if isAuthenticated() 
        && request.auth.uid == request.resource.data.deletedBy;
      
      // No updates or deletes
      allow update, delete: if false;
    }

    // ============================================
    // TOP-LEVEL ACTIVITIES (Legacy - if used)
    // ============================================
    match /activities/{activityId} {
      // Users can only read activities where they are the recipient
      allow read: if isAuthenticated() 
        && request.auth.uid == resource.data.toUserId;
      
      // All writes handled by Cloud Functions
      allow write: if false;
    }

    // ============================================
    // TOP-LEVEL FAVORITES (Legacy - if used)
    // ============================================
    match /favorites/{favoriteId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() 
        && request.auth.uid == request.resource.data.userId;
      allow update: if isAuthenticated() 
        && request.auth.uid == resource.data.userId;
      allow delete: if isAuthenticated() 
        && request.auth.uid == resource.data.userId;
    }

    // ============================================
    // COLLECTION GROUP RULES
    // For queries that span multiple subcollections
    // ============================================
    
    // Favorites collection group query rule
    // Allows users to query favorites where they are the target (toUserId)
    // This enables "favorited me" counts and listings
    match /{path=**}/favorites/{docId} {
      allow read: if isAuthenticated() 
        && request.auth.uid == resource.data.toUserId;
    }
  }
}
